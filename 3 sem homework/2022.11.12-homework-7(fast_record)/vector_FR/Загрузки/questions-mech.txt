I Структурные типы данных

1) Что такое большие объекты?
2) Приведите пример большого объекта.
3) Что такое маленькие объекты?
4) Приведите пример маленького объекта.
5) Что нужно добавить в заголовке метода, если он реализуется снаружи своего класса?
6) Что такое указатель this?
7) Какой объект имеется ввиду, если в теле метода используется имя поля без указания конкретного объекта?
8) Каковы правила перегрузки методов?
9) Каковы особенности списка параметров при перегрузке операций как методов?
10) Какое имя функции нужно использовать при перегрузке операции сложения?
11) Каковы особенности списка параметров при перегрузке операций инкремента и декремента?
12) Назовите два способа перегрузки арифметических операций и операций сравнения?
13) В каких случаях нужно использовать перегрузку операции как метод?
14) В каких случаях нужно использовать перегрузку операции как внешнюю функцию?
15) Как трактуется выражение x+y, если операция сложения перегружена как метод?
16) Как трактуется выражение x+y, если операция сложения перегружена как внешняя функция?
17) Какие операции не могут быть перегружены?
18) Какие операции могут быть перегружены только как методы?
19) Каким должен быть заголовок метода, перегружающего операцию преобразования типа?
20) Каковы правила трактовки выражения p->a компилятором?
21) Каков должен быть заголовок метода, перегружающего операцию присваивания?
22) Как явно запретить использование операции присваивания?
23) Как явно указать компилятору автоматически реализовать операцию присваивания?
24) Какую пользу можно извлечь из сокрытия полей структурного типа данных?
25) Как скрыть поля структуры, оставив методы открытыми?
26) Что означает и как используется ключевое слово public?
27) Что означает и как используется ключевое слово private?
28) Что означает тот факт, что функция f является другом класса C?
29) Что означает тот факт, что класс F является другом класса C?
30) Чем отличается ключевое слово class от struct?
31) Что и где надо написать, чтобы сделать функцию f другом класса C?
32) Что и где надо написать, чтобы сделать класс F другом класса C?
33) Чем статическое поле класса отличается от обычного?
34) Что и где нужно написать, чтобы сделать поле статическим?
35) Чем статический метод отличается от обычного?
36) Что и где нужно написать, чтобы сделать метод статическим?
37) Для чего нужны конструкторы?
38) Чем может быть имя конструктора?
39) Можно ли в одном классе иметь несколько конструкторов, и если да, то при каких условиях?
40) Что такое конструктор по умолчанию?
41) Что такое конструктор преобразования?
42) Что такое конструктор копирования?
43) В каких ситуациях используется конструктор по умолчанию?
44) В каких ситуациях используется конструктор преобразования?
45) В каких ситуациях используется конструктор копирования?
46) Где используется и что означает ключевое слово explicit?
47) Что такое конструктор перемещения?
48) Каков порядок вызова конструкторов всей структуры и ее отдельных полей?
49) Когда вызываются конструкторы глобальных переменных?
50) Когда вызываются конструкторы статических локальных переменных?
51) Когда вызываются конструкторы обычных локальных переменных?
52) Когда вызываются конструкторы динамических переменных?
53) Что такое и для чего нужен деструктор?
54) Можно ли в одном классе иметь несколько деструкторов, и если да, то при каких условиях?
55) Каковы должны быть имя и параметры деструктора?
56) Когда вызываются деструкторы глобальных и статических локальных переменных?
57) Когда вызываются деструкторы обычных локальных переменных?
58) Когда вызываются деструкторы временных безымянных объектов?
59) Что и где нужно написать, чтобы определить константу структурного типа?
60) Какие методы можно вызывать у константного объекта?
61) Что и где нужно написать, чтобы значение поля можно было менять даже у константных объектов?
62) Как убрать у объекта признак константности?
63) Как определить указатель на поле?
64) Что можно присвоить указателю на поле?
65) Как воспользоваться указателем на поле?
66) Как определить указатель на метод?
67) Что можно присвоить указателю на метод?
68) Как воспользоваться указателем на поле?
69) Чем объединение отличается от структуры?
70) Что такое безымянное объединение?
71) Для чего используются объединения?

II Шаблоны

1) Объявление и определение шаблонных функций.
2) Чем могут быть шаблонные параметры?
3) Когда возможно автоматическое определение шаблонных параметров при вызове функции?
4) Что делать, если автоматическое определение шаблонных параметров при вызове функции невозможно?
5) Что такое пакет шаблонных параметров?
6) Как и где можно использовать пакеты шаблонных параметров?
7) Как и где можно использовать пакеты параметров функции?
8) Что нужно написать, чтобы получить число элементов массива-параметра в шаблонном параметре?
9) Как заставить компилятор построить функцию из заданного шаблона, указав явно значения шаблонных параметров?
10) Как шаблоны функций соотносятся с идеей раздельной компиляции?
11) Объявления и определения шаблонных классов?
12) Вложенные типы.
13) Пример обобщенного программирования на C++.
14) Пример метапрограммирования.
15) Пример методов с дополнительными шаблонными параметрами.
16) Когда инстанциируются методы шаблонных классов?
17) Как организовать функций-шаблонных друзей у шаблонных классов?
18) Как заставить компилятор явно инстанциировать шаблонный класс, явно указав шаблонные параметры?
19) Что такое и для чего нужны concepts в C++?
20) Классы линейных контейнеров.
21) Классы ассоциативных контейнеров.
22) Виды итераторов по возрастанию их возможностей.
23) Итераторы чтения и записи из потоков.
24) Итератор для добавления элементов в конец вектора.
25) Синтаксис и смысл алгоритма swap.
26) Синтаксис и смысл алгоритма sort.
27) Синтаксис и смысл алгоритма find.
28) Синтаксис и смысл алгоритма copy.
29) Синтаксис и смысл алгоритма remove.
30) Синтаксис и смысл алгоритма lower_bound.
31) Синтаксис и смысл алгоритма upper_bound.
32) Специальная форма цикла for для перебора элементов контейнера.
33) Что такое инвалидация итераторов?
34) Пример ситуации, в которой возникает инвалидация итераторов.

III Наследование

1) Синтаксис наследования.
2) Терминология, используемая при наследовании.
3) Наследование как отношение между классами.
4) Как обычно изображается отношение наследования на диаграмме классов?
5) Что такое множественное наследование?
6) Для чего нужны виртуальные базовые классы?
7) Как инициализируются производные классы, если при наследовании использовались виртуальные базовые классы?
8) Что такое переопределение метода базового класса в производном?
9) Какие методы не наследуются?
10) Что такое, как объявляются/определяются и для чего нужны виртуальные методы?
11) Что такое чисто виртуальные методы?
12) Что такое абстрактные классы?
13) Какие ограничения существуют при использовании абстрактных классов?
14) Что такое диспетчеризация?
15) Как реализовать множественную диспетчеризацию?
16) Что такое полиморфизм?
17) Какие классы называются полиморфными?
18) Для чего используется RTTI?
19) Что такое повышающее и понижающее преобразования?
20) Синтаксис и смысл dynamic_cast?
21) Что обозначает и как используется ключевое слово protected?
22) Каков порядок вызова конструкторов и деструкторов при наследовании?
